// Tags And Layers Builder - Auto Generate Tags and Layers classes containing consts for all variables for code completion - 2012-08-03
// released under MIT License
// http://www.opensource.org/licenses/mit-license.php
//
//@author		Devin Reimer - AlmostLogical Software
//@website 		http://blog.almostlogical.com
/*
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

//#define DISABLE_AUTO_GENERATION
#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.IO;
using System.Linq;
using System.Reflection;

/// <summary>
/// Constants generator kit.
/// Note that generation by default will only happen if you use the Edit -> Generate Constants Classes menu item. 
/// You can turn on auto generation by opening the ConstantsGeneratorKit.cs file and uncommenting the first line 
/// defining the DISABLE_AUTO_GENERATION symbol.
/// This class uses UnityEditorInternal which is an undocumented internal feature
/// </summary>
public class ConstantClassesGenerator : MonoBehaviour
{
	private const string FOLDER_LOCATION = "Scripts/_AutoGenerated/";
	private static ConstantNamingStyle CONSTANT_NAMING_STYLE = ConstantNamingStyle.UppercaseWithUnderscores;
	private const string DIGIT_PREFIX = "k";
	private static string[] IGNORE_RESOURCES_IN_SUBFOLDERS = new string[] { "ProCore", "2DToolkit", "Plugins", "HairyPlotter" };
	private static bool SHOW_SUCCESS_MESSAGE = true;
	
	private const string TAGS_FILE_NAME = "KTags.cs";
	private const string LAYERS_FILE_NAME = "KLayers.cs";
	private const string SCENES_FILE_NAME = "KScenes.cs";
	private const string RESOURCE_PATHS_FILE_NAME = "KResources.cs";
	
	private static string header = "// This class is auto-generated by " + typeof(ConstantClassesGenerator).Name + ". Do not modify\n";
	
	private static string TOTAL_SCENES_CONSTANT_NAME = CONSTANT_NAMING_STYLE == ConstantNamingStyle.UppercaseWithUnderscores ? "TOTAL_SCENES" : "TotalScenes";
	
	
	[MenuItem( "Edit/Generate Constants Classes..." )]
	static void rebuildConstantsClassesMenuItem()
	{
		rebuildConstantsClasses();
	}
	
	
	public static void rebuildConstantsClasses( bool buildResources = true, bool buildScenes = true, bool buildTagsAndLayers = true )
	{
		var folderPath = Application.dataPath + "/" + FOLDER_LOCATION;
		if( !Directory.Exists(folderPath ) )
			Directory.CreateDirectory( folderPath );
		
		if( buildTagsAndLayers )
		{
			File.WriteAllText( folderPath + TAGS_FILE_NAME, getClassContent( TAGS_FILE_NAME.Replace( ".cs", string.Empty ), UnityEditorInternal.InternalEditorUtility.tags ) );
			File.WriteAllText( folderPath + LAYERS_FILE_NAME, getLayerClassContent( LAYERS_FILE_NAME.Replace( ".cs", string.Empty ), UnityEditorInternal.InternalEditorUtility.layers ) );
			
			AssetDatabase.ImportAsset( "Assets/" + FOLDER_LOCATION + TAGS_FILE_NAME, ImportAssetOptions.ForceUpdate );
			AssetDatabase.ImportAsset( "Assets/" + FOLDER_LOCATION + LAYERS_FILE_NAME, ImportAssetOptions.ForceUpdate );
		}
		
		if( buildScenes )
		{
			File.WriteAllText( folderPath + SCENES_FILE_NAME, getEnumContent( SCENES_FILE_NAME.Replace( ".cs", string.Empty ), editorBuildSettingsScenesToNameStrings( EditorBuildSettings.scenes ) ) );
			AssetDatabase.ImportAsset( "Assets/" + FOLDER_LOCATION + SCENES_FILE_NAME, ImportAssetOptions.ForceUpdate );
		}
		
		if( buildResources )
		{
			File.WriteAllText( folderPath + RESOURCE_PATHS_FILE_NAME, getResourcePathsContent( RESOURCE_PATHS_FILE_NAME.Replace( ".cs", string.Empty ) ) );
			AssetDatabase.ImportAsset( "Assets/" + FOLDER_LOCATION + RESOURCE_PATHS_FILE_NAME, ImportAssetOptions.ForceUpdate );
		}
		
		if( SHOW_SUCCESS_MESSAGE && buildResources && buildScenes && buildTagsAndLayers )
			Debug.Log( "ConstantsGeneratorKit complete. Constants classes built to " + FOLDER_LOCATION );
	}
	
	
	private static string[] editorBuildSettingsScenesToNameStrings( EditorBuildSettingsScene[] scenes )
	{
		var sceneNames = new string[scenes.Length];
		for( var n = 0; n < sceneNames.Length; n++ )
			sceneNames[n] = Path.GetFileNameWithoutExtension( scenes[n].path );
		
		return sceneNames;
	}
	
	
	private static string getEnumContent( string className, string[] labelsArray )
	{
		string output = "";
		output += header;
		output += "public enum " + className + "\n";
		output += "{\n";
		
		int i=0;
		foreach( var label in labelsArray ) {
			output += "\t" + label;
			output += " = " + i;
			if (i < labelsArray.Length - 1)
				output += ",\n";
			else
				output += "\n";
			++i;
		}
		
		output += "\n";
		output += "}";
		
		return output;
	}
	
	
	private static string getClassContent( string className, string[] labelsArray )
	{
		var output = "";
		output += header;
		output += "public static class " + className + "\n";
		output += "{\n";
		
		foreach( var label in labelsArray )
			output += "\t" + buildConstVariable( label ) + "\n";
		
		if( className == SCENES_FILE_NAME.Replace( ".cs", string.Empty ) )
		{
			output += "\n\tpublic const int " + TOTAL_SCENES_CONSTANT_NAME + " = " + labelsArray.Length + ";\n\n";
		}
		
		output += "}";
		
		return output;
	}
	
	
	private class Resource
	{
		public string name;
		public string path;
		
		public Resource( string path )
		{
			// get the path from the Resources folder root with normalized slashes
			string fullAssetsPath = Path.GetFullPath("Assets").Replace('\\', '/');
			path = path.Replace('\\', '/');
			path = path.Replace(fullAssetsPath, "");
			var parts = path.Split( new string[] { "Resources/" }, StringSplitOptions.RemoveEmptyEntries );
			
			// strip the extension from the path
			this.path = parts[1].Replace( Path.GetFileName( parts[1] ), Path.GetFileNameWithoutExtension( parts[1] ) );
			this.name = Path.GetFileNameWithoutExtension( parts[1] );
		}
	}
	
	
	private static string getResourcePathsContent( string className )
	{
		var output = "";
		output += header;
		output += "public static class " + className + "\n";
		output += "{\n";
		
		// find all our Resources folders
		var dirs = Directory.GetDirectories( Application.dataPath, "Resources", SearchOption.AllDirectories );
		var resources = new List<Resource>();
		
		foreach( var dir in dirs )
		{
			// limit our ignored folders
			var shouldAddFolder = true;
			foreach( var ignoredDir in IGNORE_RESOURCES_IN_SUBFOLDERS )
			{
				if( dir.Contains( ignoredDir ) )
				{
					shouldAddFolder = false;
					continue;
				}
			}
			
			if( shouldAddFolder )
				resources.AddRange( getAllResourcesAtPath( dir ) );
		}
		
		var resourceNamesAdded = new List<string>();
		var constantNamesAdded = new List<string>();
		foreach( var res in resources )
		{
			if( resourceNamesAdded.Contains( res.name ) )
			{
				Debug.LogWarning( "multiple resources with name " + res.name + " found. Skipping " + res.path );
				continue;
			}
			
			string constantName = formatConstVariableName(res.name);
			if( constantNamesAdded.Contains( constantName ) )
			{
				Debug.LogWarning( "multiple resources with constant name " + constantName + " found. Skipping " + res.path );
				continue;
			}
			
			
			output += "\t" + buildConstVariable( res.name, "", res.path ) + "\n";
			resourceNamesAdded.Add( res.name );
			constantNamesAdded.Add( constantName );
		}
		
		output += "}";
		
		return output;
	}
	
	
	private static List<Resource> getAllResourcesAtPath( string path )
	{
		var resources = new List<Resource>();
		
		// handle files
		var files = Directory.GetFiles( path, "*", SearchOption.AllDirectories );
		foreach( var f in files )
		{
			if( f.EndsWith( ".meta" ) || f.EndsWith( ".db" ) || f.EndsWith( ".DS_Store" ) )
				continue;
			
			resources.Add( new Resource( f ) );
		}
		
		return resources;
	}
	
	
	private static string getLayerClassContent( string className, string[] labelsArray )
	{
		var output = "";
		output += header;
		output += "public static class " + className + "\n";
		output += "{\n";
		
		foreach( var label in labelsArray )
			output += "\t" + "public const int " + formatConstVariableName( label ) + " = " + LayerMask.NameToLayer( label ) + ";\n";
		
		output += "\n\n";
		output += @"	public static int onlyIncluding( params int[] layers )
	{
		int mask = 0;
		for( var i = 0; i < layers.Length; i++ )
			mask |= ( 1 << layers[i] );

		return mask;
	}


	public static int everythingBut( params int[] layers )
	{
		return ~onlyIncluding( layers );
	}";
		
		output += "\n";
		output += "}";

		return output;
	}
	
	
	private static string buildConstVariable( string varName, string suffix = "", string value = null )
	{
		value = value ?? varName;
		return "public const string " + formatConstVariableName( varName ) + suffix + " = " + '"' + value + '"' + ";";
	}
	
	
	private static string formatConstVariableName( string input )
	{
		switch ( CONSTANT_NAMING_STYLE ) {
			case ConstantNamingStyle.UppercaseWithUnderscores:
				return toUpperCaseWithUnderscores( input );
			case ConstantNamingStyle.CamelCase:
				return toCamelCase( input );
			default:
				return toUpperCaseWithUnderscores( input );
		}
	}
	
	private static string toCamelCase( string input )
	{
		input = input.Replace( " ", "" );
		
		if ( char.IsLower(input[0]) )
			input = char.ToUpper( input[0] ) + input.Substring( 1 );
		
		// uppercase letters before dash or underline
		Func<char,int,string> func = ( x, i ) =>{
			if ( x == '-' || x == '_' )
			return "";
			
			if( i > 0 && (input[i - 1] == '-' || input[i - 1] == '_') )
			return x.ToString().ToUpper();
			
			return x.ToString();
		};
		input = string.Concat( input.Select( func ).ToArray() );
		
		// digits are a no-no so stick prefix in front
		if( char.IsDigit( input[0] ) )
			return DIGIT_PREFIX + input;
		return input;
	}
	
	private static string toUpperCaseWithUnderscores( string input )
	{
		input = input.Replace( "-", "_" );
		input = Regex.Replace( input, @"\s+", "_" );
		
		// make camel-case have an underscore between letters
		Func<char,int,string> func = ( x, i ) =>
		{
			if( i > 0 && char.IsUpper( x ) && char.IsLower( input[i - 1] ) )
			return "_" + x.ToString();
			return x.ToString();
		};
		input = string.Concat( input.Select( func ).ToArray() );
		
		// digits are a no-no so stick prefix in front
		if( char.IsDigit( input[0] ) )
			return DIGIT_PREFIX + input.ToUpper();
		return input.ToUpper();
	}
	
	private enum ConstantNamingStyle {
		UppercaseWithUnderscores,
		CamelCase
	}
}


#if !DISABLE_AUTO_GENERATION
// this post processor listens for changes to the TagManager and automatically rebuilds all classes if it sees a change
public class ConstandsGeneratorPostProcessor : AssetPostprocessor
{
	// for some reason, OnPostprocessAllAssets often gets called multiple times in a row. This helps guard against rebuilding classes
	// when not necessary.
	static DateTime? _lastTagsAndLayersBuildTime;
	static DateTime? _lastScenesBuildTime;

	static void OnPostprocessAllAssets( string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths )
	{
		var resourcesDidChange = importedAssets.Any( s => Regex.IsMatch( s, @"/Resources/.*", System.Text.RegularExpressions.RegexOptions.IgnoreCase ) );
		
		if( !resourcesDidChange )
			resourcesDidChange = movedAssets.Any( s => Regex.IsMatch( s, @"/Resources/.*", System.Text.RegularExpressions.RegexOptions.IgnoreCase ) );
		
		if( !resourcesDidChange )
			resourcesDidChange = deletedAssets.Any( s => Regex.IsMatch( s, @"/Resources/.*", System.Text.RegularExpressions.RegexOptions.IgnoreCase ) );
		
		if( resourcesDidChange )
			ConstantClassesGenerator.rebuildConstantsClasses( true, false, false );
		
		
		// layers and tags changes
		if( importedAssets.Contains( "ProjectSettings/TagManager.asset" ) )
		{
			if( !_lastTagsAndLayersBuildTime.HasValue || _lastTagsAndLayersBuildTime.Value.AddSeconds( 5 ) < DateTime.Now )
			{
				_lastTagsAndLayersBuildTime = DateTime.Now;
				ConstantClassesGenerator.rebuildConstantsClasses( false, false );
			}
		}
		
		
		// scene changes
		if( importedAssets.Contains( "ProjectSettings/EditorBuildSettings.asset" ) )
		{
			if( !_lastScenesBuildTime.HasValue || _lastScenesBuildTime.Value.AddSeconds( 5 ) < DateTime.Now )
			{
				_lastScenesBuildTime = DateTime.Now;
				ConstantClassesGenerator.rebuildConstantsClasses( false, true );
			}
		}
	}
}
#endif

#endif